<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frog Acronym Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #000; }
    </style>
</head>
<body>
    <script>
    const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 650,
        backgroundColor: '#000000',
        scene: {
            preload: preload,
            create: create,
            update: update
        },
        physics: {
            default: 'arcade',
            arcade: {
                debug: false
            }
        }
    };

    const game = new Phaser.Game(config);
    let frog;
    let acronyms;
    let cursors;
    let scoreText;
    let score = 0;
    let walls;

    const ACRONYMS = {
        'ARK': 'Account Resource Kit',
        'BIAB': 'Back in a Bit',
        'CAD': 'Connected Account Detail',
        'CAS': 'Customer Authentication Service',
        'CDE': 'Complex Deal Review',
        'DEB': 'Dashboard Eligible Business'
    };

    function preload() {
        this.load.image('frog', 'bufo.png');
    }

    function create() {
        // Create game area group
        const gameArea = this.add.group();

        // Create walls
        walls = this.physics.add.staticGroup();
        createMaze(this);

        // Create frog
        frog = this.physics.add.sprite(60, 60, 'frog');
        frog.setScale(0.25);
        frog.setCollideWorldBounds(true);
        frog.body.setSize(20, 20);

        // Create acronyms
        acronyms = this.add.group();
        Object.keys(ACRONYMS).forEach(acronym => {
            const { x, y } = getRandomPosition(this);
            const acronymText = this.add.text(x, y, acronym, { 
                fontSize: '16px', 
                fill: '#fff'
            });
            acronyms.add(acronymText);
            this.physics.add.existing(acronymText, false);
            acronymText.body.setSize(acronymText.width, acronymText.height);
            acronymText.setData('acronym', acronym);
        });

        this.physics.add.collider(frog, walls);
        this.physics.add.overlap(frog, acronyms, collectAcronym, null, this);

        cursors = this.input.keyboard.createCursorKeys();

        scoreText = this.add.text(400, 620, 'Score: 0', { 
            fontSize: '32px', 
            fill: '#fff' 
        }).setOrigin(0.5);
    }

    function update() {
        if (!frog.body) return;

        const speed = 160;
        frog.setVelocity(0);

        if (cursors.left.isDown) {
            frog.setVelocityX(-speed);
        } else if (cursors.right.isDown) {
            frog.setVelocityX(speed);
        }

        if (cursors.up.isDown) {
            frog.setVelocityY(-speed);
        } else if (cursors.down.isDown) {
            frog.setVelocityY(speed);
        }

        frog.body.velocity.normalize().scale(speed);
    }

    function collectAcronym(frog, acronym) {
        if (!acronym.getData) return; // Skip if not a valid acronym

        const acronymText = acronym.getData('acronym');
        if (!acronymText) return; // Skip if no acronym data

        // Remove the acronym
        acronym.destroy();
        
        // Update score
        score += 10;
        scoreText.setText('Score: ' + score);
        
        // Show expanded text
        const expandedText = this.add.text(400, 300, `${acronymText}: ${ACRONYMS[acronymText]}`, {
            fontSize: '24px',
            fill: '#fff'
        }).setOrigin(0.5).setDepth(1);

        // Fade out the expanded text
        this.time.delayedCall(2000, () => {
            this.tweens.add({
                targets: expandedText,
                alpha: 0,
                duration: 1000,
                ease: 'Power2',
                onComplete: () => expandedText.destroy()
            });
        });
    }

    function createMaze(scene) {
        // Coordinates for the outline of the maze
        const pathPoints = [
            // Outer border
            [40, 40, 760, 40],  // Top
            [40, 40, 40, 560],  // Left
            [40, 560, 760, 560],  // Bottom
            [760, 40, 760, 560],  // Right
            
            // Inner horizontal lines
            [120, 120, 360, 120],
            [440, 120, 680, 120],
            [120, 200, 680, 200],
            [120, 280, 680, 280],
            [120, 360, 680, 360],
            [120, 440, 680, 440],
            [120, 520, 680, 520],
            
            // Inner vertical lines
            [120, 120, 120, 520],
            [200, 120, 200, 520],
            [280, 120, 280, 520],
            [360, 120, 360, 520],
            [440, 120, 440, 520],
            [520, 120, 520, 520],
            [600, 120, 600, 520],
            [680, 120, 680, 520]
        ];

        // Draw the maze paths
        pathPoints.forEach(([x1, y1, x2, y2]) => {
            const line = scene.add.line(0, 0, x1, y1, x2, y2, 0x0000FF);
            line.setLineWidth(4);
            
            // Create invisible wall for collision
            const wall = scene.add.rectangle(
                (x1 + x2) / 2,
                (y1 + y2) / 2,
                Math.abs(x2 - x1) || 4,
                Math.abs(y2 - y1) || 4,
                0x0000FF, 0  // Invisible wall
            );
            walls.add(wall);
        });
    }

    function getRandomPosition(scene) {
        const cellSize = 80;
        const gridOffsetX = 60;
        const gridOffsetY = 60;
        
        let x, y;
        do {
            const gridX = Phaser.Math.Between(0, 8);
            const gridY = Phaser.Math.Between(0, 6);
            x = gridOffsetX + gridX * cellSize;
            y = gridOffsetY + gridY * cellSize;
        } while (isPositionOccupied(scene, x, y));
        
        return { x, y };
    }

    function isPositionOccupied(scene, x, y) {
        let occupied = false;
        scene.physics.overlapRect(x - 20, y - 20, 40, 40).forEach(body => {
            if (body.gameObject !== frog) {
                occupied = true;
            }
        });
        return occupied;
    }
    </script>
</body>
</html>
